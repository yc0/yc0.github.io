<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++ vtable ptr & vtable | My journey</title><meta name=keywords content="c++,vtable,virtual"><meta name=description content="C++ vtable/vtable ptr C++中的virtual
本文參考C++中關於 virtual 的兩三事,並且加上自己的經驗而紀錄。
 
static binding vs. dynamic binding
在 virtual 之前得先提到 binding。binding 一般指的是把一個東西對應到另一個東西上，在 C++ 中，binding 指的是函式呼叫與函式定義的連接，這個時機可能發生於 compile-time 或是 run-time，依據情況而定。
在 static binding 中，compiler 會在 compile-time 時就把函式定義與函式呼叫連結起來，因為比較早連接起來，所以又叫做 early binding。而在 dynamic binding 的情形中，這樣的連接會一直延遲至 run-time 才會發生，因此也可稱為 late binding。在 C++ 中，dynamic binding 主要可以透過 virtual 來達成。
在 static binding 中，由於呼叫函式的所有資訊都已經提前先知道了，所以在程式真正執行起來會比較快一些；反之，dynamic binding 的好處在於在 run-time 才決定，因此可以更彈性地呼叫函式。
vtable/ vtable ptr
當我們宣告某個 class 的函式為 virtual 時，代表若有 derived class 的話，該函式可以被 redefined。virtual function 的 implementation 是透過 virtual table, or vtable 與 virtual table pointer, or vtable ptr。
只要一個 class 中有一個以上的 virtual 函式，那麼該instance(每一個由該 class 產生的 object)都會包含一個vtable與一個指向這個vtable的指標,vtable ptr。我們可以將 virtual table 想像成陣列，而陣列中的每個元素都是個指向 virtual 函式的 implementation 的指標。"><meta name=author content="Nelson"><link rel=canonical href=https://yc0.github.io/posts/c-vtable-ptr-vtable/><link crossorigin=anonymous href=/assets/css/stylesheet.a090830a421002426baafbd314e38f149d77b4c48a12ee9312700d770b27fb26.css integrity="sha256-oJCDCkIQAkJrqvvTFOOPFJ13tMSKEu6TEnANdwsn+yY=" rel="preload stylesheet" as=style><link rel=icon href=https://yc0.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yc0.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yc0.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yc0.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yc0.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://yc0.github.io/posts/c-vtable-ptr-vtable/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://yc0.github.io/posts/c-vtable-ptr-vtable/"><meta property="og:site_name" content="My journey"><meta property="og:title" content="C++ vtable ptr & vtable"><meta property="og:description" content="C++ vtable/vtable ptr C++中的virtual 本文參考C++中關於 virtual 的兩三事,並且加上自己的經驗而紀錄。
static binding vs. dynamic binding 在 virtual 之前得先提到 binding。binding 一般指的是把一個東西對應到另一個東西上，在 C++ 中，binding 指的是函式呼叫與函式定義的連接，這個時機可能發生於 compile-time 或是 run-time，依據情況而定。 在 static binding 中，compiler 會在 compile-time 時就把函式定義與函式呼叫連結起來，因為比較早連接起來，所以又叫做 early binding。而在 dynamic binding 的情形中，這樣的連接會一直延遲至 run-time 才會發生，因此也可稱為 late binding。在 C++ 中，dynamic binding 主要可以透過 virtual 來達成。 在 static binding 中，由於呼叫函式的所有資訊都已經提前先知道了，所以在程式真正執行起來會比較快一些；反之，dynamic binding 的好處在於在 run-time 才決定，因此可以更彈性地呼叫函式。
vtable/ vtable ptr 當我們宣告某個 class 的函式為 virtual 時，代表若有 derived class 的話，該函式可以被 redefined。virtual function 的 implementation 是透過 virtual table, or vtable 與 virtual table pointer, or vtable ptr。 只要一個 class 中有一個以上的 virtual 函式，那麼該instance(每一個由該 class 產生的 object)都會包含一個vtable與一個指向這個vtable的指標,vtable ptr。我們可以將 virtual table 想像成陣列，而陣列中的每個元素都是個指向 virtual 函式的 implementation 的指標。"><meta property="og:locale" content="zh-tw"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-10-08T00:50:18+00:00"><meta property="article:modified_time" content="2025-10-25T10:47:02+08:00"><meta property="article:tag" content="C++"><meta property="article:tag" content="Vtable"><meta property="article:tag" content="Virtual"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++ vtable ptr & vtable"><meta name=twitter:description content="C++ vtable/vtable ptr C++中的virtual
本文參考C++中關於 virtual 的兩三事,並且加上自己的經驗而紀錄。
 
static binding vs. dynamic binding
在 virtual 之前得先提到 binding。binding 一般指的是把一個東西對應到另一個東西上，在 C++ 中，binding 指的是函式呼叫與函式定義的連接，這個時機可能發生於 compile-time 或是 run-time，依據情況而定。
在 static binding 中，compiler 會在 compile-time 時就把函式定義與函式呼叫連結起來，因為比較早連接起來，所以又叫做 early binding。而在 dynamic binding 的情形中，這樣的連接會一直延遲至 run-time 才會發生，因此也可稱為 late binding。在 C++ 中，dynamic binding 主要可以透過 virtual 來達成。
在 static binding 中，由於呼叫函式的所有資訊都已經提前先知道了，所以在程式真正執行起來會比較快一些；反之，dynamic binding 的好處在於在 run-time 才決定，因此可以更彈性地呼叫函式。
vtable/ vtable ptr
當我們宣告某個 class 的函式為 virtual 時，代表若有 derived class 的話，該函式可以被 redefined。virtual function 的 implementation 是透過 virtual table, or vtable 與 virtual table pointer, or vtable ptr。
只要一個 class 中有一個以上的 virtual 函式，那麼該instance(每一個由該 class 產生的 object)都會包含一個vtable與一個指向這個vtable的指標,vtable ptr。我們可以將 virtual table 想像成陣列，而陣列中的每個元素都是個指向 virtual 函式的 implementation 的指標。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yc0.github.io/posts/"},{"@type":"ListItem","position":2,"name":"C++ vtable ptr \u0026 vtable","item":"https://yc0.github.io/posts/c-vtable-ptr-vtable/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++ vtable ptr \u0026 vtable","name":"C\u002b\u002b vtable ptr \u0026 vtable","description":"C++ vtable/vtable ptr C++中的virtual 本文參考C++中關於 virtual 的兩三事,並且加上自己的經驗而紀錄。\nstatic binding vs. dynamic binding 在 virtual 之前得先提到 binding。binding 一般指的是把一個東西對應到另一個東西上，在 C++ 中，binding 指的是函式呼叫與函式定義的連接，這個時機可能發生於 compile-time 或是 run-time，依據情況而定。 在 static binding 中，compiler 會在 compile-time 時就把函式定義與函式呼叫連結起來，因為比較早連接起來，所以又叫做 early binding。而在 dynamic binding 的情形中，這樣的連接會一直延遲至 run-time 才會發生，因此也可稱為 late binding。在 C++ 中，dynamic binding 主要可以透過 virtual 來達成。 在 static binding 中，由於呼叫函式的所有資訊都已經提前先知道了，所以在程式真正執行起來會比較快一些；反之，dynamic binding 的好處在於在 run-time 才決定，因此可以更彈性地呼叫函式。\nvtable/ vtable ptr 當我們宣告某個 class 的函式為 virtual 時，代表若有 derived class 的話，該函式可以被 redefined。virtual function 的 implementation 是透過 virtual table, or vtable 與 virtual table pointer, or vtable ptr。 只要一個 class 中有一個以上的 virtual 函式，那麼該instance(每一個由該 class 產生的 object)都會包含一個vtable與一個指向這個vtable的指標,vtable ptr。我們可以將 virtual table 想像成陣列，而陣列中的每個元素都是個指向 virtual 函式的 implementation 的指標。\n","keywords":["c++","vtable","virtual"],"articleBody":"C++ vtable/vtable ptr C++中的virtual 本文參考C++中關於 virtual 的兩三事,並且加上自己的經驗而紀錄。\nstatic binding vs. dynamic binding 在 virtual 之前得先提到 binding。binding 一般指的是把一個東西對應到另一個東西上，在 C++ 中，binding 指的是函式呼叫與函式定義的連接，這個時機可能發生於 compile-time 或是 run-time，依據情況而定。 在 static binding 中，compiler 會在 compile-time 時就把函式定義與函式呼叫連結起來，因為比較早連接起來，所以又叫做 early binding。而在 dynamic binding 的情形中，這樣的連接會一直延遲至 run-time 才會發生，因此也可稱為 late binding。在 C++ 中，dynamic binding 主要可以透過 virtual 來達成。 在 static binding 中，由於呼叫函式的所有資訊都已經提前先知道了，所以在程式真正執行起來會比較快一些；反之，dynamic binding 的好處在於在 run-time 才決定，因此可以更彈性地呼叫函式。\nvtable/ vtable ptr 當我們宣告某個 class 的函式為 virtual 時，代表若有 derived class 的話，該函式可以被 redefined。virtual function 的 implementation 是透過 virtual table, or vtable 與 virtual table pointer, or vtable ptr。 只要一個 class 中有一個以上的 virtual 函式，那麼該instance(每一個由該 class 產生的 object)都會包含一個vtable與一個指向這個vtable的指標,vtable ptr。我們可以將 virtual table 想像成陣列，而陣列中的每個元素都是個指向 virtual 函式的 implementation 的指標。\n如底下的程式碼\nclass Base { public: virtual void func1(); virtual void func1(); void nonVirtualFunc(); }; class Derived : public Base { public: virtual void func2() override; void nonVirtualFunc(); }; Derived myDerived; Base myBase; 當我們呼叫一個 instance 的 virtual 函式時，compiler 其實做了這三件事情\n由該 instance的 vtable vptr 找到其 vtable。 找到 vtable 中，符合該函式的指標。 執行前一步指標所指向的位置 在這邊我們有 class Base 含有兩個 virtual 函式 func1(), func2() 與 non-virtual 函式 nonVirtualFunc()，class Derived 繼承 Base，含有 override 的 virtual 函式 func2() 與 non-virtual 函式 nonVirtualFunc()。假設我們有兩個物件：一個 Base 的 object myBase 與另一個 Derived 的 object myDerived。那麼我們可以這樣子想像他們的關係： myBase 物件中包含ptr，該指標指向其 vtable。在這邊因為有兩個 virtual 函式 func1(), func2()，所以 vtable 包含了兩個元素。而這兩個元素分別指向 Base::func1() 的 implementation 與 Base::func2() 的implementation。 myDerived 物件同樣地也包含了指向其 vtable ptr，vtable 也有兩個元素因為有兩個 virtual 函式 func1(), func2()，其中因為 Derived 沒有 override 函式 func1()，所以其指標指向的是 Base::func1() 的 implementation。另一方面，關於函式 func2() 的指標則指向 Derived::func2() 的 implementation\n值得一提的是，vtable 中都不包含關於函式 nonVirtualFunc() 的元素，因為該函式不是 virtual。\nPublic inheritance 裡 class 中的 virtual 函式 接著這邊來討論一下在 inheritance 中，一個 class 裡的函式什麼時候該加 virtual，什麼時候不該加 virtual\n首先我們先定義interface 函式宣告 和 函式定義\ninterface 函式宣告 std::size_t numDigits(int number); implementation 函式定義 std::size_t numDigits(int number) { std::size_t digitsSoFar = 1; while((number/=10)!=0) ++digitsSoFar; return digitsSoFar; } 當我們提到 inheritance 時，我們要先想清楚這個 function 想要繼承的是函式宣告還是函式定義; inheritance of interface 指的是我們只想要繼承函式的宣告，而 inheritance of implementation 則是繼承函式的定義。什麼時候該下 virtual 取決於我們想要繼承的是什麼：有時候只想要繼承函式宣告、有時候想要繼承函式宣告與定義，但允許 override 其定義、有時候想要繼承兩者但不允許 override 其定義。我們可以透過下面這個例子來說明:\nclass Shape { { public: virtual void draw() const = 0; virtual void error(const std::string\u0026 msg); int objectID() const; … }; class Rectangle: public Shape{…}; class Ellipse: public Shape{…}; 在這邊 Shape 是個abstract class(不能被具現化instantiated)，因為它包含至少一個純虛擬函式，此外，考慮到 public inheritance 的意義是 is-a(as opposite to private inheritance is has-a)；在任何從 Shape public inherited 的 derived class 中，所有函式的 interface 都必須被繼承。\nPure virtual 純虛擬函式 Pure virtual 的特性使得它們必須被 derived class 重新宣告，且它們在 abstract class 沒有定義。宣告 pure virtual 函式的意義為，derived class 僅僅繼承函式的 interface。\nShape::draw 告訴所有 derived class「你必須提供 draw 函式，至於你要如何 implement 我並不清楚」。在這個例子中也相當正確，畢竟要分別畫出 Rectangle 與 Ellipse 的演算法應該差異非常大\n宣告 pure virtual 函式的意義為，derived class 僅僅繼承函式的 interface\nvirtual 虛擬函式 virtual function or simple virtual function 則稍有不同。首先 derived class 仍然繼承函式的 interface，第二是 simple virtual 函式提供了一個 implementation，即函式定義。但是 derived class 可以 override。意即\n宣告 simple virtual 函式的意義為，derived class 繼承函式的 interface 以及其 default implementation\nShape 透過這個意思告訴所有 derived class「你要提供 error 函式，但如果你不想要寫自己的版本的話，你可以用我的版本」。\nnon-virtual 函式 在 non-virtual 函式中，derived class 最好保留著函式原本的行為，不應該自己重新定義函式。同樣地，加上 derived class 繼承函式的 interface 後，我們可以這樣理解\n宣告 non-virtual 函式的意義為，繼承函式的 interface 以及不更改函式原本的 implementation。\npure virtual/ virtual / non-virtual 小結 綜合上述三者，當一個 class 預計被當成 base class 時，通常都會有為數不少的 virtual 函式。但倘若真的存在某些函式不應該被重新定義時，請不要幫他們任意加上 virtual\nderived chain / inheritance chain 在繼承階層中，第一個建立的建構子是base class，這裡要說明一下，virtual是有穿透性(沒有人這樣形容，但其行為很像，有人再修正我一下, 參考自 When should my destructor be virtual)，Classes按一定的順序執行(Depth-first-left-to-right)，逐步更換vtable 中的implementation。\nThe very first constructors to be executed are the virtual base classes anywhere in the hierarchy. They are executed in the order they appear in a depth-first left-to-right traversal (從base class到derived classes) of the graph of base classes, where left to right refer to the order of appearance of base class names.\nAfter all virtual base class constructors are finished, the construction order is generally from base class to derived class. The details are easiest to understand if you imagine that the very first thing the compiler does in the derived class’s ctor is to make a hidden call to the ctors of its non-virtual base classes (hint: that’s the way many compilers actually do it). So if class D inherits multiply from B1 and B2, the constructor for B1 executes first, then the constructor for B2, then the constructor for D. This rule is applied recursively; for example, if B1 inherits from B1a and B1b, and B2 inherits from B2a and B2b, then the final order is B1a, B1b, B1, B2a, B2b, B2, D.\n小結 virtual是有穿透性:再你的繼承物件中，如果您的基類具有虛擬方法，則您自己的方法是自動虛擬的。由於其他原因，您可能需要明確定義(explicit)方法，但不需要重新聲明virtual，確保它是虛擬的。不管你用虛擬聲明它，沒有虛擬聲明它，或者根本不聲明它，它仍然是虛擬的。 Classes按一定的順序執行(Depth-first-left-to-right)，逐步更換vtable 中的implementation virtual inheritance. 多重繼承時，會有一種模擬兩可的情況，就是當兩個類別都繼承同一個基底類別，而這兩個類別又同時被另一個類別，以平行多重繼承的方式同時繼承 C類別將會擁有兩個A類別的複本，一個來自B1所繼承下來的，一個來自B2所繼承下來的，Compiler將會Confuse C類別的A是來自B1 或B2\nvirtual inheritance可解決這個問題。\nclass A { // implementation }; class B1 : **virtual public A** { // implementation }; class B2 : **virtual public A** { // implementation }; class C : public B1, public B2 { // implementation }; B1與B2以虛擬繼承的方式繼承了A類別，這個好處是當有類別多重繼承了某個基底類別時，在該類別中將會只有一個基底類別存在，而不會有多個複 本\nvirtual destructor 為避免不可預期的錯誤，在security code中，要求base class的destrutor必須virtual。不多說，直接看例子，秒懂。\nDeleting a derived class object using a pointer to a base class that has a non-virtual destructor results in undefined behavior. To correct this situation, the base class should be defined with a virtual destructor. For example, following program results in undefined behavior.\nclass base { public: base() { cout\u003c\u003c\"Constructing base \\n\"; } ~base() { cout\u003c\u003c\"Destructing base \\n\"; } }; class derived: public base { public: derived() { cout\u003c\u003c\"Constructing derived \\n\"; } ~derived() { cout\u003c\u003c\"Destructing derived \\n\"; } }; output\nConstructing base Constructing derived Destructing base derived的 destructor並未執行，因為這不是override而是hidden。正確的寫法應是：\nclass base { public: base() { cout\u003c\u003c\"Constructing base \\n\"; } virtual ~base() { cout\u003c\u003c\"Destructing base \\n\"; } }; class derived: public base { public: derived() { cout\u003c\u003c\"Constructing derived \\n\"; } ~derived() { cout\u003c\u003c\"Destructing derived \\n\"; } }; output\nConstructing base Constructing derived Destructing derived Destructing base 結論 virtual 的好處是避免冗余的程式碼，但需要多佔一些空間以及增加run-time，當然還有一些 virtual 的其他小細節\npolymorphic bases class destructor 盡量要 virtual盡量避免讓 virtual 遇上 inline multiple inheritance 中 使用 virtual base class override virtual 函式加上 override確保你正在override一個interface而不是create一個函式。 這裡補完C++中關於 virtual 的兩三事提點的資料。\n","wordCount":"843","inLanguage":"en","datePublished":"2019-10-08T00:50:18Z","dateModified":"2025-10-25T10:47:02+08:00","author":{"@type":"Person","name":"Nelson"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yc0.github.io/posts/c-vtable-ptr-vtable/"},"publisher":{"@type":"Organization","name":"My journey","logo":{"@type":"ImageObject","url":"https://yc0.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yc0.github.io/ accesskey=h title="My journey (Alt + H)">My journey</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yc0.github.io/posts/ title="All Posts"><span>All Posts</span></a></li><li><a href=https://yc0.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://yc0.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://yc0.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://yc0.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">C++ vtable ptr & vtable</h1><div class=post-meta><span title='2019-10-08 00:50:18 +0000 UTC'>October 8, 2019</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>Nelson</span></div></header><div class=post-content><h2 id=c-vtablevtable-ptr-c中的virtual>C++ vtable/vtable ptr C++中的virtual<a hidden class=anchor aria-hidden=true href=#c-vtablevtable-ptr-c中的virtual>#</a></h2><p>本文參考<a href=https://medium.com/theskyisblue/c-%E4%B8%AD%E9%97%9C%E6%96%BC-virtual-%E7%9A%84%E5%85%A9%E4%B8%89%E4%BA%8B-1b4e2a2dc373>C++中關於 virtual 的兩三事</a>,並且加上自己的經驗而紀錄。</p><h3 id=static-binding-vs-dynamic-binding>static binding vs. dynamic binding<a hidden class=anchor aria-hidden=true href=#static-binding-vs-dynamic-binding>#</a></h3><p>在 virtual 之前得先提到 binding。binding 一般指的是把一個東西對應到另一個東西上，在 C++ 中，binding 指的是函式呼叫與函式定義的連接，這個時機可能發生於 compile-time 或是 run-time，依據情況而定。
在 static binding 中，compiler 會在 compile-time 時就把函式定義與函式呼叫連結起來，因為比較早連接起來，所以又叫做 early binding。而在 dynamic binding 的情形中，這樣的連接會一直延遲至 run-time 才會發生，因此也可稱為 late binding。在 C++ 中，dynamic binding 主要可以透過 virtual 來達成。
在 static binding 中，由於呼叫函式的所有資訊都已經提前先知道了，所以在程式真正執行起來會比較快一些；反之，dynamic binding 的好處在於在 run-time 才決定，因此可以更彈性地呼叫函式。</p><h3 id=vtable-vtable-ptr>vtable/ vtable ptr<a hidden class=anchor aria-hidden=true href=#vtable-vtable-ptr>#</a></h3><p>當我們宣告某個 class 的函式為 virtual 時，代表若有 derived class 的話，該函式可以被 redefined。virtual function 的 implementation 是透過 virtual table, or vtable 與 virtual table pointer, or vtable ptr。
只要一個 class 中有一個以上的 virtual 函式，那麼該instance(每一個由該 class 產生的 object)都會包含一個vtable與一個指向這個vtable的指標,vtable ptr。我們可以將 virtual table 想像成陣列，而陣列中的每個元素都是個指向 virtual 函式的 implementation 的指標。</p><p>如底下的程式碼</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Base</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> func1();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func1</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>nonVirtualFunc</span>();
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Derived</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Base
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> func2() <span style=color:#66d9ef>override</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>nonVirtualFunc</span>();
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>Derived myDerived;
</span></span><span style=display:flex><span>Base myBase;
</span></span></code></pre></div><p>當我們呼叫一個 instance 的 virtual 函式時，compiler 其實做了這三件事情</p><ol><li>由該 instance的 vtable vptr 找到其 vtable。</li><li>找到 vtable 中，符合該函式的指標。</li><li>執行前一步指標所指向的位置</li></ol><img loading=lazy src=professional.JPG><p>在這邊我們有 class Base 含有兩個 virtual 函式 func1(), func2() 與 non-virtual 函式 nonVirtualFunc()，class Derived 繼承 Base，含有 override 的 virtual 函式 func2() 與 non-virtual 函式 nonVirtualFunc()。假設我們有兩個物件：一個 Base 的 object myBase 與另一個 Derived 的 object myDerived。那麼我們可以這樣子想像他們的關係：
myBase 物件中包含ptr，該指標指向其 vtable。在這邊因為有兩個 virtual 函式 func1(), func2()，所以 vtable 包含了兩個元素。而這兩個元素分別指向 Base::func1() 的 implementation 與 Base::func2() 的implementation。
myDerived 物件同樣地也包含了指向其 vtable ptr，vtable 也有兩個元素因為有兩個 virtual 函式 func1(), func2()，其中因為 Derived 沒有 override 函式 func1()，所以其指標指向的是 Base::func1() 的 implementation。另一方面，關於函式 func2() 的指標則指向 Derived::func2() 的 implementation</p><p>值得一提的是，vtable 中都不包含關於函式 nonVirtualFunc() 的元素，因為<strong>該函式不是 virtual</strong>。</p><h3 id=public-inheritance-裡-class-中的-virtual-函式>Public inheritance 裡 class 中的 virtual 函式<a hidden class=anchor aria-hidden=true href=#public-inheritance-裡-class-中的-virtual-函式>#</a></h3><p>接著這邊來討論一下在 inheritance 中，一個 class 裡的函式什麼時候該加 virtual，什麼時候不該加 virtual</p><p>首先我們先定義<strong>interface 函式宣告</strong> 和 <strong>函式定義</strong></p><h4 id=interface-函式宣告>interface 函式宣告<a hidden class=anchor aria-hidden=true href=#interface-函式宣告>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>std<span style=color:#f92672>::</span>size_t numDigits(<span style=color:#66d9ef>int</span> number);
</span></span></code></pre></div><h4 id=implementation-函式定義>implementation 函式定義<a hidden class=anchor aria-hidden=true href=#implementation-函式定義>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>std<span style=color:#f92672>::</span>size_t numDigits(<span style=color:#66d9ef>int</span> number)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>size_t digitsSoFar <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>((number<span style=color:#f92672>/=</span><span style=color:#ae81ff>10</span>)<span style=color:#f92672>!=</span><span style=color:#ae81ff>0</span>) <span style=color:#f92672>++</span>digitsSoFar;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> digitsSoFar;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>當我們提到 inheritance 時，我們要先想清楚這個 function 想要繼承的是<strong>函式宣告</strong>還是<strong>函式定義</strong>; inheritance of interface 指的是我們只想要繼承函式的宣告，而 inheritance of implementation 則是繼承函式的定義。什麼時候該下 virtual 取決於我們想要繼承的是什麼：有時候只想要繼承函式宣告、有時候想要繼承函式宣告與定義，但允許 override 其定義、有時候想要繼承兩者但不允許 override 其定義。我們可以透過下面這個例子來說明:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Shape</span> {
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> draw() <span style=color:#66d9ef>const</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>error</span>(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> msg);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>objectID</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>…</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Rectangle</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Shape{<span style=color:#960050;background-color:#1e0010>…</span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Ellipse</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Shape{<span style=color:#960050;background-color:#1e0010>…</span>};
</span></span></code></pre></div><p>在這邊 Shape 是個abstract class(不能被具現化instantiated)，因為它包含至少一個純虛擬函式，此外，考慮到 public inheritance 的意義是 is-a(as opposite to private inheritance is has-a)；在任何從 Shape public inherited 的 derived class 中，所有函式的 interface 都必須被繼承。</p><h4 id=pure-virtual-純虛擬函式>Pure virtual 純虛擬函式<a hidden class=anchor aria-hidden=true href=#pure-virtual-純虛擬函式>#</a></h4><p>Pure virtual 的特性使得它們必須被 derived class <strong>重新宣告</strong>，且它們在 abstract class 沒有定義。宣告 pure virtual 函式的意義為，derived class 僅僅繼承函式的 interface。</p><p>Shape::draw 告訴所有 derived class「你必須提供 draw 函式，至於你要如何 implement 我並不清楚」。在這個例子中也相當正確，畢竟要分別畫出 Rectangle 與 Ellipse 的演算法應該差異非常大</p><blockquote><p>宣告 pure virtual 函式的意義為，derived class 僅僅繼承函式的 interface</p></blockquote><h4 id=virtual-虛擬函式>virtual 虛擬函式<a hidden class=anchor aria-hidden=true href=#virtual-虛擬函式>#</a></h4><p>virtual function or simple virtual function 則稍有不同。首先 derived class 仍然繼承函式的 interface，第二是 simple virtual 函式提供了一個 implementation，即<strong>函式定義</strong>。但是 derived class 可以 override。意即</p><blockquote><p>宣告 simple virtual 函式的意義為，derived class 繼承函式的 interface 以及其 default implementation</p></blockquote><p>Shape 透過這個意思告訴所有 derived class「你要提供 error 函式，但如果你不想要寫自己的版本的話，你可以用我的版本」。</p><h4 id=non-virtual-函式>non-virtual 函式<a hidden class=anchor aria-hidden=true href=#non-virtual-函式>#</a></h4><p>在 non-virtual 函式中，derived class 最好保留著函式原本的行為，不應該自己重新定義函式。同樣地，加上 derived class 繼承函式的 interface 後，我們可以這樣理解</p><blockquote><p>宣告 non-virtual 函式的意義為，繼承函式的 interface 以及不更改函式原本的 implementation。</p></blockquote><h4 id=pure-virtual-virtual--non-virtual-小結>pure virtual/ virtual / non-virtual 小結<a hidden class=anchor aria-hidden=true href=#pure-virtual-virtual--non-virtual-小結>#</a></h4><p>綜合上述三者，當一個 class 預計被當成 base class 時，通常都會有為數不少的 virtual 函式。但倘若真的存在某些函式<code>不應該被重新定義時，請不要幫他們任意加上 virtual</code></p><h3 id=derived-chain--inheritance-chain>derived chain / inheritance chain<a hidden class=anchor aria-hidden=true href=#derived-chain--inheritance-chain>#</a></h3><p>在繼承階層中，第一個建立的建構子是base class，這裡要說明一下，virtual是有穿透性(沒有人這樣形容，但其行為很像，有人再修正我一下, 參考自 <a href=https://isocpp.org/wiki/faq/virtual-functions#virtual-dtors>When should my destructor be virtual</a>)，Classes按一定的順序執行(Depth-first-left-to-right)，逐步更換vtable 中的implementation。</p><blockquote><p>The very first constructors to be executed are the virtual base classes anywhere in the hierarchy. They are executed in the order they appear in a <strong>depth-first left-to-right traversal</strong> (從base class到derived classes) of the graph of base classes, where left to right refer to the order of appearance of base class names.</p></blockquote><blockquote><p>After all virtual base class constructors are finished, the construction order is generally from base class to derived class. The details are easiest to understand if you imagine that the very first thing the compiler does in the derived class’s ctor is to make a hidden call to the ctors of its non-virtual base classes (hint: that’s the way many compilers actually do it). So if class D inherits multiply from B1 and B2, the constructor for B1 executes first, then the constructor for B2, then the constructor for D. This rule is applied recursively; for example, if B1 inherits from B1a and B1b, and B2 inherits from B2a and B2b, then the final order is B1a, B1b, B1, B2a, B2b, B2, D.</p></blockquote><h4 id=小結>小結<a hidden class=anchor aria-hidden=true href=#小結>#</a></h4><ul><li>virtual是有穿透性:再你的繼承物件中，如果您的基類具有虛擬方法，則您自己的方法是自動虛擬的。由於其他原因，您可能需要明確定義(explicit)方法，但不需要重新聲明virtual，確保它是虛擬的。不管你用虛擬聲明它，沒有虛擬聲明它，或者根本不聲明它，它仍然是虛擬的。</li><li>Classes按一定的順序執行(Depth-first-left-to-right)，逐步更換vtable 中的implementation</li></ul><h3 id=virtual-inheritance>virtual inheritance.<a hidden class=anchor aria-hidden=true href=#virtual-inheritance>#</a></h3><p>多重繼承時，會有一種模擬兩可的情況，就是當兩個類別都繼承同一個基底類別，而這兩個類別又同時被另一個類別，以平行多重繼承的方式同時繼承
<img alt=示意圖 loading=lazy src=C-vtable-ptr-vtable/virtualInheritance.JPG></p><p>C類別將會擁有兩個A類別的複本，一個來自B1所繼承下來的，一個來自B2所繼承下來的，Compiler將會Confuse C類別的A是來自B1 或B2</p><p><strong>virtual inheritance</strong>可解決這個問題。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// implementation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B1</span> <span style=color:#f92672>:</span> <span style=color:#f92672>**</span><span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>public</span> A<span style=color:#f92672>**</span> {  
</span></span><span style=display:flex><span>    <span style=color:#75715e>// implementation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B2</span> <span style=color:#f92672>:</span> <span style=color:#f92672>**</span><span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>public</span> A<span style=color:#f92672>**</span> {  
</span></span><span style=display:flex><span>    <span style=color:#75715e>// implementation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>C</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> B1, <span style=color:#66d9ef>public</span> B2 {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// implementation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><p>B1與B2以虛擬繼承的方式繼承了A類別，這個<code>好處是當有類別多重繼承了某個基底類別時，在該類別中將會只有一個基底類別存在</code>，而不會有多個複 本</p><h3 id=virtual-destructor>virtual destructor<a hidden class=anchor aria-hidden=true href=#virtual-destructor>#</a></h3><p>為避免不可預期的錯誤，在security code中，要求base class的destrutor必須virtual。不多說，直接看例子，秒懂。</p><blockquote><p>Deleting a derived class object using a pointer to a base class that has a non-virtual destructor results in undefined behavior. To correct this situation, the base class should be defined with a virtual destructor. For example, following program results in undefined behavior.</p></blockquote><pre tabindex=0><code>class base { 
  public: 
    base()      
    { cout&lt;&lt;&#34;Constructing base \n&#34;; } 
    ~base() 
    { cout&lt;&lt;&#34;Destructing base \n&#34;; }      
}; 
  
class derived: public base { 
  public: 
    derived()      
    { cout&lt;&lt;&#34;Constructing derived \n&#34;; } 
    ~derived() 
    { cout&lt;&lt;&#34;Destructing derived \n&#34;; } 
}; 
</code></pre><p><strong>output</strong></p><pre tabindex=0><code>Constructing base
Constructing derived
Destructing base
</code></pre><p>derived的 destructor並未執行，因為這不是override而是hidden。正確的寫法應是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>base</span> { 
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span> 
</span></span><span style=display:flex><span>    base()      
</span></span><span style=display:flex><span>    { cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;Constructing base </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>; } 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#f92672>~</span>base() 
</span></span><span style=display:flex><span>    { cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;Destructing base </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>; }      
</span></span><span style=display:flex><span>}; 
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>derived</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> base { 
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span> 
</span></span><span style=display:flex><span>    derived()      
</span></span><span style=display:flex><span>    { cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;Constructing derived </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>; } 
</span></span><span style=display:flex><span>    <span style=color:#f92672>~</span>derived() 
</span></span><span style=display:flex><span>    { cout<span style=color:#f92672>&lt;&lt;</span><span style=color:#e6db74>&#34;Destructing derived </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>; } 
</span></span><span style=display:flex><span>}; 
</span></span></code></pre></div><p><strong>output</strong></p><pre tabindex=0><code>Constructing base
Constructing derived
Destructing derived
Destructing base
</code></pre><h4 id=結論>結論<a hidden class=anchor aria-hidden=true href=#結論>#</a></h4><p>virtual 的好處是避免冗余的程式碼，但需要多佔一些空間以及增加run-time，當然還有一些 virtual 的其他小細節</p><ul><li>polymorphic bases class destructor</li><li>盡量要 virtual盡量避免讓 virtual 遇上 inline</li><li>multiple inheritance 中 使用 virtual base class</li><li>override virtual 函式加上 override確保你正在override一個interface而不是<em><strong>create</strong></em>一個函式。</li></ul><p>這裡補完<a href=https://medium.com/theskyisblue/c-%E4%B8%AD%E9%97%9C%E6%96%BC-virtual-%E7%9A%84%E5%85%A9%E4%B8%89%E4%BA%8B-1b4e2a2dc373>C++中關於 virtual 的兩三事</a>提點的資料。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://yc0.github.io/tags/c++/>C++</a></li><li><a href=https://yc0.github.io/tags/vtable/>Vtable</a></li><li><a href=https://yc0.github.io/tags/virtual/>Virtual</a></li></ul><nav class=paginav><a class=prev href=https://yc0.github.io/posts/static-class-member-initialization-in-c/><span class=title>« Prev</span><br><span>class static member initialization in C++</span>
</a><a class=next href=https://yc0.github.io/posts/c-print-pretty/><span class=title>Next »</span><br><span>C++ Print Pretty</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yc0.github.io/>My journey</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>